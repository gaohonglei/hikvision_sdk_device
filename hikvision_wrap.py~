#!/usr/bin/env python
# -*- coding: utf-8 -*-
import sys, os, collections, threading, time, traceback, os
import logging, os, logging.handlers
import Vistek.Data as v_data

from memory_profiler import profile
#import line_profiler
try:
    import Queue
except:
    import queue as Queue
file_name = "{0}-{1}".format(__name__, os.getpid())
if not os.path.exists("log"):
    os.mkdir("log")
log_file = "log\{0}.log".format(file_name)
log_level = logging.DEBUG

logger = logging.getLogger(file_name)
handler = logging.handlers.TimedRotatingFileHandler(log_file, when="D", interval=1)
formatter = logging.Formatter(
    "[%(asctime)s] [%(levelname)s] [%(name)s] [%(filename)s:%(funcName)s:%(lineno)s]  %(message)s")

handler.setFormatter(formatter)
logger.addHandler(handler)
logger.setLevel(log_level)
from ctypes import *

try:
    import xml.etree.cElementTree as ET
except:
    import xml.etree.ElementTree as ET

import vistek_util.workTemplate as work_template

if sys.platform == 'win32':
    DllHandle = None
else:
    DllHandle = cdll

Session = collections.namedtuple('Session', 'device_id session_id ip port user pwd')
PushServerInfo = collections.namedtuple('PushServerInfo', 'ip port')

device_lists = dict()
device_status_lists = dict()# deviceID+channel status
push_server_lists = dict()
device_info_lists = dict() #deviceid deviceinfo
status_queue = Queue.Queue()

is_start = False


def get_device_info_list():
    global device_info_lists
    return device_info_lists


def get_device_lists():
    global device_lists
    return device_lists


def get_device_status_lists():
    global device_status_lists
    return device_status_lists


def get_push_server_lists():
    global push_server_lists
    return push_server_lists


def get_status_queue():
    global status_queue
    return status_queue


device_xml_node = ET.Element('devices')


def enum(**enums):
    return type('Enum', (), enums)
V_PTZ_CMD_TYPE = enum(LIGHT_PWRON=2, WIPER_PWRON=3, FAN_PWRON=4, HEATER_PWRON=5, AUX_PWRON1=6,
                      AUX_PWRON2=7, SET_PRESET=8, CLE_PRESET=9, ZOOM_IN=11, ZOOM_OUT=12, FOCUS_NEAR=13, FOCUS_FAR=14,
                      IRIS_OPEN=15, IRIS_CLOSE=16, TILT_UP=21, TILT_DOWN=22, PAN_LEFT=23,
                      PAN_RIGHT=24, LEFT_UP=25, RIGHT_UP=26, LEFT_DOWN=27, RIGHT_DOWN=28,
                      PAN_AUTO=29, GOTO_PRESET=39, TILT_DOWN_ZOOM_IN=58, TILT_DOWN_ZOOM_OUT=59, PAN_LEFT_ZOOM_IN=60,
                      PAN_LEFT_ZOOM_OUT=61, PAN_RIGHT_ZOOM_IN=62, PAN_RIGHT_ZOOM_OUT=63,
                      UP_LEFT_ZOOM_IN=64, UP_LEFT_ZOOM_OUT=65, UP_RIGHT_ZOOM_IN=66, UP_RIGHT_ZOOM_OUT=67,
                      DOWN_LEFT_ZOOM_IN=68, DOWN_LEFT_ZOOM_OUT=69, DOWN_RIGHT_ZOOM_IN=70,
                      DOWN_RIGHT_ZOOM_OUT=71, TILT_UP_ZOOM_IN=72, TILT_UP_ZOOM_OUT=73)
NET_DVR_DEV_TYPE = enum (DVR=1, ATMDVR=2, DVS=3, DEC=4, ENC_DEC=5, DVR_HC=6, DVR_HT=7,
                         DVR_HF=8, DVR_HS=9, DVR_HTS=10, DVR_HB=11, DVR_HCS=12, DVS_A=13,
                         DVR_HC_S=14, DVR_HT_S=15, DVR_HF_S=16, DVR_HS_S=17, ATMDVR_S=18,
                         DVR_7000H=19, DEC_MAT=20, DVR_MOBILE=21, DVR_HD_S=22, DVR_HD_SL=23,
                         DVR_HC_SL=24, DVR_HS_ST=25, DVS_HW=26, DS630X_D=27, DS640X_HD=28,
                         DS610X_D=29, IPCAM=30, MEGA_IPCAM=31, IPCAM_X62MF=32, ITCCAM=35,
                         IVS_IPCAM=36, ZOOMCAM=38, IPDOME=40, IPDOME_MEGA200=41, IPDOME_MEGA130=42,
                         TII_IPCAM=44, IPMOD=50, IDS6501_HF_P=60, IDS6101_HF_A=61, IDS6002_HF_B=62,
                         IDS6101_HF_B=63, IDS52XX=64, IDS90XX=65, IDS8104_AHL_S_HX=66, IDS8104_AHL_S_H=67,
                         IDS91XX=68, IIP_CAM_B=69, IIP_CAM_F=70, DS71XX_H=71, DS72XX_H_S=72, DS73XX_H_S=73,
                         DS72XX_HF_S=74, DS73XX_HFI_S=75, DS76XX_H_S=76, DS76XX_N_S=77, DS81XX_HS_S=81,
                         DS81XX_HL_S=82, DS81XX_HC_S=83, DS82XX_HD_S=84, DS82XX_HE_S=85, DS82XX_HF_S=86,
                         DS81XX_AH_S=87, DS81XX_AHF_S=88, DS90XX_HF_S=90, DS91XX_HF_S=91, DS91XX_HD_S=92,
                         IDS90XX_A=93, IDS91XX_A=94, DS95XX_N_S=95, DS96XX_N_SH=96, DS90XX_HF_SH=97,
                         DS91XX_HF_SH=98, DS_65XXHC=105, DS65XXHC_S=106, DS_65XXHF=107, DS_65XXHF_S=108,
                         DS_6500HF_B=109, IVMS_6200_C=110, IVMS_6200_B=111, DS72XXHV_ST15=112, DS72XXHV_ST20=113,
                         IVMS_6200_T=114, IVMS_6200_BP=115, DS_81XXHC_ST=116, DS_81XXHS_ST=117, DS_81XXAH_ST=118,
                         DS_81XXAHF_ST=119, DS_66XXDVS=120, DS_19AXX=142, DS_19CXX=144, DS_19DXX=145, DS_19XX=146,
                         DS_19SXX=147, DS_1HXX=148, DS_C10H=161, DS_C10N_BI=162, DS_C10N_DI=163, DS_C10N_SI=164,
                         DS_C10N_DO=165, DS_C10N_SERVER=166, IDS_8104_AHFL_S_H=171, IDS_65XX_HF_A=172, IDS90XX_HF_RH=173,
                         IDS91XX_HF_RH=174, IDS_65XX_HF_B=175, IDS_65XX_HF_P=176, IVMS_6200_F=177, IVMS_6200_F_S=179,
                         DS90XX_HF_RH=181, DS91XX_HF_RH=182, DS78XX_S=183, DS81XXHW_ST=186, DS91XXHW_ST=187,
                         DS91XX_ST=188, DS81XX_ST=189, DS81XXH_ST=190, DS73XXH_ST=191, DS81XX_SH=192, DS81XX_SN=193,
                         DS96XXN_ST=194, DS86XXN_ST=195, DS80XXHF_ST=196, DS90XXHF_ST=197, DS76XXN_ST=198, DS9664N_RX=199,
                         ENCODER_SERVER=200, DECODER_SERVER=201, PCNVR_SERVER=202, CVR_SERVER=203, DS_91XXHFH_ST=204,
                         DS_66XXHFH=205, TRAFFIC_TS_SERVER=210, TRAFFIC_VAR=211, IPCALL=212, DS64XXHD_T=701, DS_65XXD=703,
                         DS63XXD_T=704, DS_64XXHD_S=706, DS_68XXT=707, DS65XXD_T=708, DS_K260X=850, IPCAM_FISHEYE=1002,
                         IPCAM_BINOCULAR=1004, TRAFFIC_ECT=1400, TRAFFIC_PARKING_SERVER=1401, DS90XXHW_ST=2001,
                         DS72XXHX_SH=2002, DS_92XX_HF_ST=2003, DS_91XX_HF_XT=2004, DS_90XX_HF_XT=2005, DS_73XXHX_SH=2006,
                         DS_72XXHFH_ST=2007, DS_67XXHF_SATA=2008, DS_67XXHW=2009, DS_67XXHW_SATA=2010, DS_67XXHF=2011,
                         DS_6772XXHF_SV=2012, DS_72XXHW_SV=2013, DS_81XXHX_SH=2014, DS_71XXHX_SL=2015, DS_77XXN_ST=2201,
                         DS_95XX_N_ST=2202, DS_85XX_N_ST=2203, DS_96XX_N_XT=2204, DS_76XX_N_SE=2205, DS_86XXSN_SX=2206,
                         DS_96XX_N_RX=2207, DS_96XXX_N_E=2213, DS_76XXN_EX=2214, DS_77XXN_E4=2215, DS_86XXN_E8=2216,
                         DS_81XXTHFH_E=2217, DS_96XXN_FX=2230, DS_86XXN_FX=2231, PCNVR_IVMS_4200=2301, IVMS_6200_TP=2401,
                         IVMS_6200_TF=2402)

class NET_DVR_PROTO_TYPE(Structure):
    _fields_ = [('dwType', c_ulong),
                ('byDescribe', c_ubyte*16)]
    def __str__(self):
        return "dwType:{0} byDescribe:{1}".format(self.dwType, self.byDescribe)

class NET_DVR_IPC_PROTO_LIST(Structure):
    _fields_ = [('dwsize', c_ulong),
                ('dwProtoNum', c_ulong),
                ('struProto', NET_DVR_PROTO_TYPE*50),
                ('byRes', c_ubyte*8)]
    def __str__(self):
        return "dwsize:{0} dwProtoNum:{1} struProto:{2} byRes:{3}".format(self.dwsize, self.dwProtoNum, self.struProto, self.byRes)

class NET_DVR_DIGITAL_CHANNEL_STATE(Structure):
    _fields_ = [
        ('dwsize', c_ulong),
        ('byDigitalAudioChanTalkState', c_ubyte*64),
        ('byDigitalChanState', c_ubyte*64),
        ('byDigitalAudioChanTalkStateEx', c_ubyte*64*3),
        ('byDigitalChanStateEx', c_ubyte*64*3),
        ('byRes', c_ubyte*64)
    ]

class NET_DVR_IPADDR(Structure):
    _fields_ = [
        ('sIpV4', c_char*16),
        ('sIpV6', c_char*128)
    ];

    def __str__(self):
        return "{0}:{1}".format(self.sIpV4, self.sIpV6)


class NET_DVR_IPDEVINFO_V31(Structure):
    _fields_ = [
        ('byEnable', c_ubyte),
        ('byProType', c_ubyte),
        ('byEnableQuickAdd', c_ubyte),
        ('byRes1', c_ubyte),
        ('sUserName', c_ubyte*32),
        ('sPassword', c_ubyte*16),
        ('byDomain', c_ubyte*64),
        ('struIP', NET_DVR_IPADDR),
        ('wDVRPort', c_ushort),
        ('byRes2', c_ubyte*34)
    ];

    def __str__(self):
        return "{0}:{1}:{2}:{3}:{4}:{5}:{6}:{7}:{8}:{9}".format(self.byEnable, self.byProType, self.byEnableQuickAdd, self.byRes1, self.sUserName, self.sPassword, self.byDomain, self.struIP, self.wDVRPort, self.byRes2)


class NET_DVR_IPCHANINFO(Structure):
    _fields_ = [
        ('byEnable', c_ubyte),
        ('byIPID', c_ubyte),
        ('byChannel', c_ubyte),
        ('byIPIDHigh', c_ubyte),
        ('byRes', c_ubyte*32)
    ];

class NET_DVR_STREAM_MEDIA_SERVER_CFG(Structure):
    _fields_ = [
        ('byValid', c_ubyte),
        ('byRes1', c_ubyte*3),
        ('struDevIP', NET_DVR_IPADDR),
        ('wDevPort', c_ushort),
        ('byTransmitType', c_ubyte),
        ('byRes2', c_ubyte*69)
    ];

class NET_DVR_DEV_CHAN_INFO(Structure):
    _fields_ = [
        ('struIP', NET_DVR_IPADDR),
        ('wDVRPort', c_ushort),
        ('byChannel', c_ubyte),
        ('byTransProtocol', c_ubyte),
        ('byTransMode', c_ubyte),
        ('byFactoryType', c_ubyte),
        ('byDeviceType', c_ubyte),
        ('byDispChan', c_ubyte),
        ('bySubDispChan', c_ubyte),
        ('byResolution', c_ubyte),
        ('byRes', c_ubyte*2),
        ('byDomain', c_ubyte*64),
        ('sUserName', c_ubyte*32),
        ('sPassword', c_ubyte*16)
    ];

class NET_DVR_PU_STREAM_CFG(Structure):
    _fields_ = [
        ('dwSize', c_ulong),
        ('struStreamMediaSvrCfg', NET_DVR_STREAM_MEDIA_SERVER_CFG),
        ('strDevChanInfo', NET_DVR_DEV_CHAN_INFO)
    ];

class NET_DVR_IPSERVER_STREAM(Structure):
    _fields_ = [
        ('byEnable', c_ubyte),
        ('byRes', c_ubyte),
        ('struIPServer', NET_DVR_IPADDR),
        ('wPort', c_ushort),
        ('wDvrNameLen', c_ushort),
        ('byDVRName', c_ubyte*32),
        ('wDVRSerialLen', c_ushort),
        ('byRes1', c_ushort*2),
        ('byDVRSerialNumber', c_ubyte*48),
        ('byUserName', c_ubyte*32),
        ('byPassword', c_ubyte*16),
        ('byChannel', c_ubyte),
        ('byRes2', c_ubyte*11)
    ];

class NET_DVR_DDNS_STREAM_CFG(Structure):
    _fields_ = [
        ('byEnable', c_ubyte),
        ('byRes1', c_ubyte*3),
        ('struStreamServer', NET_DVR_IPADDR),
        ('wStreamServerPort', c_ushort),
        ('byStreamServerTransmitType', c_ubyte),
        ('byRes2', c_ubyte),
        ('struIPServer', NET_DVR_IPADDR),
        ('wIPServerPort', c_ushort),
        ('byRes3', c_ubyte*2),
        ('sDVRName', c_ubyte*32),
        ('wDVRNameLen', c_ushort),
        ('wDVRSerialLen', c_ushort),
        ('sDVRSerialNumber', c_ubyte*48),
        ('sUserName', c_ubyte*32),
        ('sPassWord', c_ubyte*16),
        ('wDVRPort', c_ushort),
        ('byRes4', c_ubyte*2),
        ('byChannel', c_ubyte),
        ('byTransProtocol', c_ubyte),
        ('byTransMode', c_ubyte),
        ('byFactoryType', c_ubyte)
    ];

class NET_DVR_PU_STREAM_URL(Structure):
    _fields_ = [
        ('byEnable', c_ubyte),
        ('strURL', c_ubyte*240),
        ('byTransProtocol', c_ubyte),
        ('wIPID', c_ushort),
        ('byChannel', c_ubyte),
        ('byRes', c_ubyte*7)
    ];

class NET_DVR_HKDDNS_STREAM(Structure):
    _fields_ = [
        ('byEnable', c_ubyte),
        ('byRes', c_ubyte*3),
        ('byDDNSDomain', c_ubyte*64),
        ('wPort', c_ushort),
        ('wAliasLen', c_ushort),
        ('byAlias', c_ubyte*32),
        ('wDVRSerialLen', c_ushort),
        ('byRes1', c_ubyte*2),
        ('byDVRSerialNumber', c_ubyte*48),
        ('byUserName', c_ubyte*32),
        ('byPassWord', c_ubyte*16),
        ('byChannel', c_ubyte),
        ('byRes2', c_ubyte*11)
    ];

class NET_DVR_IPCHANINFO_V40(Structure):
    _fields_ = [
        ('byEnable', c_ubyte),
        ('byRes1', c_ubyte),
        ('wIPID', c_ushort),
        ('dwChannel', c_ulong),
        ('byTransProtocol', c_ubyte),
        ('byTransMode', c_ubyte),
        ('byFactoryType', c_ubyte),
        ('byRes', c_ubyte*241)
    ];

class NET_DVR_GET_STREAM_UNION(Union):
    _fields_ = [
        ('struChanInfo', NET_DVR_IPCHANINFO),
        ('struPUStream', NET_DVR_PU_STREAM_CFG),
        ('struIPServerStream', NET_DVR_IPSERVER_STREAM),
        ('struDDNSStream', NET_DVR_DDNS_STREAM_CFG),
        ('struStreamUrl', NET_DVR_PU_STREAM_URL),
        ('struHkDDNSStream', NET_DVR_HKDDNS_STREAM),
        ('struIPChan', NET_DVR_IPCHANINFO_V40)
    ];

class NET_DVR_STREAM_MODE(Structure):
    _fields_ = [
        ('byGetStreamType', c_ubyte),
        ('byRes', c_ubyte*3),
        ('uGetStream', NET_DVR_GET_STREAM_UNION)
    ];

class NET_DVR_IPPARACFG_V40(Structure):
    _fields_ = [
        ('dwSize', c_ulong),
        ('dwGroupNum', c_ulong),
        ('dwAchanNum', c_ulong),
        ('dwDchanNum', c_ulong),
        ('dwStartDChan', c_ulong),
        ('byAnalogChanEnable', c_ubyte*64),
        ('struIPDevInfo', NET_DVR_IPDEVINFO_V31*64),
        ('struStreamMode', NET_DVR_STREAM_MODE*64),
        ('byRes2', c_ubyte*20)
    ];

    def __str__(self):
        return "{0}:{1}:{2}:{3}:{4}:{5}".format(self.dwSize, self.dwGroupNum, self.dwAchanNum, self.dwDchanNum, self.dwStartDChan, self.byAnalogChanEnable)

class device_info_v30(Structure):
    _fields_ = [
        ('sSerialNumber', c_ubyte * 48),
        ('byAlarmInPortNum', c_ubyte),
        ('byAlarmOutPortNum', c_ubyte),
        ('byDiskNum', c_ubyte),
        ('byDVRType', c_ubyte),
        ('byChanNum', c_ubyte),
        ('byStartChan', c_ubyte),
        ('byAudioChanNum', c_ubyte),
        ('byIPChanNum', c_ubyte),
        ('byZeroChanNum', c_ubyte),
        ('byMainProto', c_ubyte),
        ('bySubProto', c_ubyte),
        ('bySupport', c_ubyte),
        ('bySupport1', c_ubyte),
        ('bySupport2', c_ubyte),
        ('wDevType', c_ushort),
        ('bySupport3', c_ubyte),
        ('byMultiStreamProto', c_ubyte),
        ('byStartDChan', c_ubyte),
        ('byStartDTalkChan', c_ubyte),
        ('byHighDChanNum', c_ubyte),
        ('bySupport4', c_ubyte),
        ('byLanguageType', c_ubyte),
        ('byVoiceInChanNum', c_ubyte),
        ('byStartVoiceInChanNo', c_ubyte),
        ('byRes3', c_ubyte * 2),
        ('byMirrorChanNum', c_ubyte),
        ('wStartMirrorChanNo', c_ubyte),
        ('byRes2', c_ubyte * 2)];


loginresult = CFUNCTYPE(c_void_p, c_long, c_ulong, POINTER(device_info_v30), c_void_p)

# exception_callback = CFUNCTYPE(c_void_p, c_ulong, c_long, c_long, c_void_p)
exception_callback = WINFUNCTYPE(c_void_p, c_ulong, c_long, c_long, c_void_p)


def do_exception(event_type, user_id, handle, user):
    # pdb.set_trace()
    logger.debug("exceptions eventtype:{0} user_id:{1} handle:{2} user:{3}".format(str(event_type), str(user_id), str(handle),
                                                                          str(user)))
    return None

exception_obj = exception_callback(do_exception)


class login_info(Structure):
    _fields_ = [('s_DeviceAddress', c_char * 129),
                ('byRes1', c_ubyte),
                ('wPort', c_ushort),
                ('sUserName', c_char * 64),
                ('sPassword', c_char * 64),
                # ('cbLoginResult', CFUNCTYPE(c_void_p, c_long, c_longlong, pointer(device_info_v30), c_void_p)),
                ('cbLoginResult', loginresult),
                ('pUser', c_void_p),
                ('bUseAsynLogin', c_bool),
                ('byRes2', c_char * 128)];

    def __str__(self):
        return '{0}:{1}:{2}:{3}'.format(self.s_DeviceAddress, self.wPort, self.sUserName, self.sPassword)


class deviceinfo_v40(Structure):
    _fields_ = [('struDeviceV30', device_info_v30),
                ('bySupportLock', c_ubyte),
                ('byRetryLoginTime', c_ubyte),
                ('byPasswordLevel', c_ubyte),
                ('byRes1', c_ubyte),
                ('dwSurplusLockTime', c_ulong),
                ('byRes2', c_ubyte * 256)];

    def __str__(self):
        return '{0}{1}'.format(self.strDeviceV30.byIPChanNum, self.byRetryLoginTime)


class hik_time(Structure):
    _fields_ = [('dwYear', c_ulong),
                ('dwMonth', c_ulong),
                ('dwDay', c_ulong),
                ('dwHour', c_ulong),
                ('dwMinute', c_ulong),
                ('dwSecond', c_ulong), ];

    def __str__(self):
        return '{0}-{1}-{2} {3}:{4}:{5}'.format(self.dwYear, self.dwMonth, self.dwDay, self.dwHour, self.dwMinute,
                                                self.dwSecond)


class rtspcfg(Structure):
    _fields_ = [('dwSize', c_ulong),
                ('wPort', c_ushort),
                ('byReserve', c_ubyte * 54)];

    def __str__(self):
        return '{0}:{1}'.format(self.dwSize, self.wPort)


def load_dll(dll_name):
    global DllHandle
    global dll_mutex
    if DllHandle is not None:
        # logger.debug("init success")
        return DllHandle
    else:
        if sys.platform == 'win32':
            other_path = os.path.abspath(os.path.join(os.path.dirname(__file__), 'HCNetSDKCom'))
            other_lib = os.path.abspath(os.path.join(os.path.dirname(__file__), 'HCCore'))
            sys.path.append(other_path)
            other_dll_handle = WinDLL(other_lib)
            dll_handle = WinDLL(dll_name)
        else:
            dll_handle = CDLL(dll_name)

    b_init = dll_handle.NET_DVR_Init()
    if b_init:
        # logger.debug("init success")
        return dll_handle
    else:
        logger.debug("init fail")
        return None


relogin_device_lists = dict()


def get_relogin_device_lists():
    global relogin_device_lists
    return relogin_device_lists


class ReLoginThread(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.setDaemon(True)

    def run(self):
        global DllHandle
        global device_lists
        global is_start
        while True:
            if sys.platform == 'win32':
                dll_path = os.path.abspath(os.path.join(os.path.dirname(__file__), 'HCNetSDK'))
                DllHandle = load_dll(dll_path)
            relogin_dev_lists = get_relogin_device_lists()
            for id, device in relogin_device_lists.items():
                hik_login_info = login_info()
                hik_device_info = deviceinfo_v40()
                memset(addressof(hik_device_info), 0, sizeof(deviceinfo_v40))
                memset(addressof(hik_login_info), 0, sizeof(login_info))
                hik_login_info.s_DeviceAddress = device.ip
                hik_login_info.wPort = device.port
                hik_login_info.sUserName = device.user
                hik_login_info.sPassword = device.pwd
                login_id = DllHandle.NET_DVR_Login_V40(pointer(hik_login_info), pointer(hik_device_info))
                if login_id != -1:
                    relogin_device_lists.pop(id)
                    old_device = device_lists.get(id)
                    status_list = get_device_status_lists()
                    if id not in status_list:
                        status_list[id] = "true"
                    else:
                        status_list.update({id:"true"})
                    login_session = Session(device_id=id, session_id=login_id, ip=device.ip, port=device.port\
                                            , user=device.user, pwd=device.pwd)
                    #old_device.session_id = login_id
                    device_lists.update({id:login_session})
                    dev_info_list = get_device_info_list()
                    if id not in dev_info_list:
                        dev_info_list[id] = hik_device_info
                    logger.debug("relogin success id:{0} ip:{1} port:{2} user:{3} pwd:{4}".format(str(id),
                                                                                                  str(device.ip),
                                                                                                  str(device.port),
                                                                                                  str(device.user),
                                                                                                  str(device.pwd)))
                    DllHandle.NET_DVR_SetConnectTime(5000, 3)
                    DllHandle.NET_DVR_SetReconnect(5000, 1)
            time.sleep(5)


@profile
def register_device(device_id, ip, port, user_name, user_pwd):
    """ register a hikvision device"""
    global DllHandle
    global device_lists
    global is_start
    global exception_obj
    if sys.platform == 'win32':
        dll_path = os.path.abspath(os.path.join(os.path.dirname(__file__), 'HCNetSDK'))
        DllHandle = load_dll(dll_path)
    relogin_dev_lists = get_relogin_device_lists()
    register_node = ET.Element('register')
    ip_node = ET.SubElement(register_node, 'ip')
    ip_node.text = ip
    session_node = ET.SubElement(register_node, 'session')
    dev_info_list = get_device_info_list()
    if device_id not in device_lists:
        hik_login_info = login_info()
        hik_device_info = deviceinfo_v40()
        memset(addressof(hik_device_info), 0, sizeof(deviceinfo_v40))
        memset(addressof(hik_login_info), 0, sizeof(login_info))
        hik_login_info.s_DeviceAddress = ip
        hik_login_info.wPort = port
        hik_login_info.sUserName = user_name
        hik_login_info.sPassword = user_pwd
        login_id = DllHandle.NET_DVR_Login_V40(pointer(hik_login_info), pointer(hik_device_info))
        DllHandle.NET_DVR_SetConnectTime(5000, 3)
        DllHandle.NET_DVR_SetReconnect(5000, 1)
        login_session = Session(device_id=device_id, session_id=login_id, ip=ip, port=port, user=user_name,
                                pwd=user_pwd)
        device_lists[device_id] = login_session
        device_xml_node.set("counts", str(len(device_lists)))
        device_node = ET.SubElement(device_xml_node, 'device')
        device_node.set('name', device_id)
        device_node.set('code', device_id)
        device_node.set('manfacture', 'hikvision')
        device_node.set('ip', ip)
        device_node.set('port', str(port))
        device_node.set('parent_id', '')
        tree = ET.ElementTree(device_xml_node)
        tree.write('device_lists.xml', encoding="UTF-8")
        status_lists = get_device_status_lists()
        if login_id == -1:
            logger.error(
                "device_id:{0} ip{1} user:{2} pwd:{3} register failed error:{4}.".format(device_id, ip\
                                                                                         , user_name, user_pwd\
                                                                                         , DllHandle.NET_DVR_GetLastError()))
            if device_id not in relogin_device_lists:
                relogin_device_lists[device_id] = login_session
            status_lists[device_id] = "false"
        else:
            exception_ret = DllHandle.NET_DVR_SetExceptionCallBack_V30(0, None, exception_obj, None)
            if 0 < hik_device_info.struDeviceV30.byIPChanNum:
                for item in range(hik_device_info.struDeviceV30.byIPChanNum):
                    status_id = "{0}:{1}".format(device_id, item+hik_device_info.struDeviceV30.byStartDChan)
                    if status_id not in status_lists:
                        status_lists[status_id] = "true"
            else:
                status_id = "{0}:{1}".format(device_id, hik_device_info.struDeviceV30.byStartChan)
                if status_id not in status_lists:
                    status_lists[status_id] = "true"
            if device_id not in dev_info_list:
                dev_info_list[device_id]= hik_device_info
            logger.info(
                "device_id:{0} ip:{1} user:{2} pwd:{3} id:{4} exceptionret:{5} register success.".format(device_id, ip,
                                                                                                         user_name,
                                                                                                         user_pwd,
                                                                                                         login_id,
                                                                                                         exception_ret))

        session_node.text = str(login_id)
    else:
        login_session = device_lists.get(device_id)
        session_node.text = str(login_session.session_id)
    session_xml = ET.tostring(register_node, encoding="UTF-8", method="xml")
    if not is_start:
        t = StartServerThread()
        t.start()
        relogin_thrd = ReLoginThread()
        relogin_thrd.start()
        is_start = True
    return (session_xml, len(session_xml))


def _make_hik_stream_url(dev_id, ip, port, username, password, channel, stream_type):
    protocol_name = "hikdvr"
    url = "{0}://{1}:{2}/realplay?did={3}&un={4}&pw={5}&ch={6}&si={7}".format(protocol_name, ip, port, dev_id\
                                                                              , username, password, channel, stream_type)
    url_id = "{0}:{1}:{2}".format(dev_id, channel, stream_type)
    return {url_id:url}

@profile
def get_stream_url(device_id, channel=None):
    global device_lists
    global DllHandle
    if not device_lists.has_key(device_id):
        return ('', 0)
    dev_info_list = get_device_info_list()
    login_session = device_lists.get(device_id)
    hik_rtsp = rtspcfg()
    DllHandle.NET_DVR_GetRtspConfig(login_session.session_id, 0, byref(hik_rtsp), sizeof(rtspcfg))
    stream_urls = dict()
    hik_stream_urls = dict()
    dev_info = dev_info_list.get(device_id)
    if device_id in dev_info_list:
        ip_access_cfg = NET_DVR_IPPARACFG_V40()
        memset(addressof(ip_access_cfg), 0, sizeof(NET_DVR_IPPARACFG_V40))
        dw_ret = c_ulong()
        ret = DllHandle.NET_DVR_GetDVRConfig(login_session.session_id, 1062, 0, pointer(ip_access_cfg),
                                             sizeof(NET_DVR_IPPARACFG_V40), pointer(dw_ret))
        if 1 < dev_info.struDeviceV30.byIPChanNum:  # nvr or dvr.
            for item in range(dev_info.struDeviceV30.byIPChanNum):
                if ip_access_cfg.struStreamMode[item].uGetStream.struChanInfo.byEnable:
                    channel_index = dev_info.struDeviceV30.byStartDChan + item
                    if dev_info.struDeviceV30.bySupport &0x80 == 0:#not support rtsp over rtp.
                        if  dev_info.struDeviceV30.byMultiStreamProto &0x40 ==1:#support main stream.
                            main_hik_url = _make_hik_stream_url(device_id, login_session.ip, login_session.port,\
                                                                login_session.user, login_session.pwd, channel_index, 0)
                            #stream_urls.update(main_hik_url)
                            hik_stream_urls.update(main_hik_url)
                        if dev_info.struDeviceV30.byMultiStreamProto &0x80 ==1:#support sub stream.
                            sub_hik_url = _make_hik_stream_url(device_id, login_session.ip, login_session.port \
                                                                , login_session.user, login_session.pwd, channel_index, 0)
                            #stream_urls.update(sub_hik_url)
                            hik_stream_urls.update(sub_hik_url)
                    else:

                        url_main = "rtsp://{0}:{1}@{2}:{3}/h264/ch{4}/main/av_stream".format(str(login_session.user),
                                                                                             str(login_session.pwd),
                                                                                             str(login_session.ip),
                                                                                             str(hik_rtsp.wPort),
                                                                                             str(channel_index))
                        #url_main_id = "{0}:{1}:{2}".format(device_id, channel_index, "0")
                        url_main_id = "{0}:{1}:{2}".format(device_id, item, "0")
                        if url_main_id not in stream_urls:
                            stream_urls[url_main_id] = url_main
                        url_sub = "rtsp://{0}:{1}@{2}:{3}/h264/ch{4}/sub/av_stream".format(str(login_session.user),
                                                                                           str(login_session.pwd),
                                                                                           str(login_session.ip),
                                                                                           str(hik_rtsp.wPort),
                                                                                           str(channel_index))
                        #url_sub_id = "{0}:{1}:{2}".format(device_id, channel_index, "1")
                        url_sub_id = "{0}:{1}:{2}".format(device_id, item, "1")
                        if url_sub_id not in stream_urls:
                            stream_urls[url_sub_id] = url_sub
            logger.debug('get_stream_url success dvr dev_id:{0} ip:{1} urls:{2}'.format(device_id, login_session.ip,
                                                                                        str(stream_urls)))
        elif 1 < dev_info.struDeviceV30.byChanNum:
            for item in range(dev_info.struDeviceV30.byChanNum):
                channel_index = dev_info.struDeviceV30.byStartChan + item
                if 0 == ret:#not support ip access
                    if dev_info.struDeviceV30.bySupport &0x80 == 0:#not support rtsp over rtp.
                        #if  dev_info.struDeviceV30.byMultiStreamProto &0x40 ==1:#support main stream.
                        main_hik_url = _make_hik_stream_url(device_id, login_session.ip, login_session.port, \
                                                            login_session.user, login_session.pwd, channel_index, 0)
                        #stream_urls.update(main_hik_url)
                        hik_stream_urls.update(main_hik_url)
                        #if dev_info.struDeviceV30.byMultiStreamProto &0x80 ==1:#support sub stream.
                        sub_hik_url = _make_hik_stream_url(device_id, login_session.ip, login_session.port \
                                                           , login_session.user, login_session.pwd, channel_index, 0)
                        #stream_urls.update(sub_hik_url)
                        hik_stream_urls.update(sub_hik_url)
                else:
                    if ip_access_cfg.byAnalogChanEnable[item]:
                        if dev_info.struDeviceV30.bySupport &0x80 == 0:#not support rtsp over rtp.
                            if  dev_info.struDeviceV30.byMultiStreamProto &0x40 ==1:#support main stream.
                                main_hik_url = _make_hik_stream_url(device_id, login_session.ip, login_session.port, \
                                                                    login_session.user, login_session.pwd, channel_index, 0)
                                #stream_urls.update(main_hik_url)
                                hik_stream_urls.update(main_hik_url)
                            if dev_info.struDeviceV30.byMultiStreamProto &0x80 ==1:#support sub stream.
                                sub_hik_url = _make_hik_stream_url(device_id, login_session.ip, login_session.port \
                                                                   , login_session.user, login_session.pwd, channel_index, 0)
                                hik_stream_urls.update(sub_hik_url)
                                #stream_urls.update(sub_hik_url)
            logger.debug("get stream url 2")
        else:  # ipc
            encode_node = ET.Element('AudioVideoCompressInfo')
            channel_node = ET.SubElement(encode_node, 'VideoChannelNumber')
            channel_node.text = str(channel)
            in_xml = ET.tostring(encode_node, encoding="UTF-8", method="xml")
            in_xml_len = c_ulong(len(in_xml))
            device_encode_ability_v20 = c_ulong(0x008)
            out_data = create_string_buffer(1024 * 10)
            out_data_len = c_ulong(1024 * 10)
            ret = DllHandle.NET_DVR_GetDeviceAbility(login_session.session_id, device_encode_ability_v20,
                                                     cast(in_xml, c_char_p), in_xml_len, out_data, out_data_len)
            root_node = ET.fromstring(out_data.value)
            channel_lists = root_node.find('./VideoCompressInfo/ChannelList')
            for main_item in channel_lists.iter('ChannelEntry'):
                main_chan = main_item.find('MainChannel')
                channel_index = main_item.find('ChannelNumber')
                if main_chan:
                    url_main = "rtsp://{0}:{1}@{2}:{3}/h264/ch{4}/main/av_stream".format(str(login_session.user),
                                                                                         str(login_session.pwd),
                                                                                         str(login_session.ip),
                                                                                         str(hik_rtsp.wPort),
                                                                                         str(channel_index.text))
                    url_main_id = "{0}:{1}:{2}".format(device_id, channel_index.text, "0")
                    if url_main_id not in stream_urls:
                        stream_urls[url_main_id] = url_main
                for sub_item in main_item.iter('SubChannelList'):
                    url_sub = "rtsp://{0}:{1}@{2}:{3}/h264/ch{4}/sub/av_stream".format(str(login_session.user),
                                                                                       str(login_session.pwd),
                                                                                       str(login_session.ip),
                                                                                       str(hik_rtsp.wPort),
                                                                                       str(channel_index.text))
                    url_sub_id = "{0}:{1}:{2}".format(device_id, channel_index.text, "1")
                    if url_sub_id not in stream_urls:
                        stream_urls[url_sub_id] = url_sub
            logger.debug('get_stream_url success ipc dev_id:{0} ip:{1} urls:{2}'.format(device_id, login_session.ip, str(stream_urls)))
    urls = ET.Element('stream_url_lists')
    urls.set("counts", str(len(stream_urls)))
    for url_id, item in stream_urls.items():
        url = ET.SubElement(urls, 'stream_url')
        url.text = item
        url.set("id", str(url_id))
        url.set("user_name", str(login_session.user))
        url.set("password", str(login_session.pwd))
        url.set("third_party", str(False))
    for uri_id, item in hik_stream_urls.items():
        url = ET.SubElement(urls, 'stream_url')
        url.text = item
        url.set("id", str(url_id))
        url.set("user_name", str(login_session.user))
        url.set("password", str(login_session.pwd))
        url.set("third_party", str(True))

    urls_xml = ET.tostring(urls, encoding='UTF-8', method='xml')
    return (urls_xml, len(urls_xml))


@profile
def get_device_status(device_id, channel=None):
    """ get device status"""
    global device_lists
    global DllHandle
    if not device_lists.has_key(device_id):
        logger.debug("id{0} not in device lists.".format(device_id))
        return ("", 0)
    remote_login_info = device_lists.get(device_id)
    session_id = None
    if DllHandle is None or not device_lists.has_key(device_id):
        dll_path = os.path.abspath(os.path.join(os.path.dirname(__file__), 'HCNetSDK'))
        DllHandle = load_dll(dll_path)
        hik_login_info = login_info()
        hik_device_info = deviceinfo_v40()
        memset(addressof(hik_device_info), 0, sizeof(deviceinfo_v40))
        memset(addressof(hik_login_info), 0, sizeof(login_info))
        hik_login_info.s_DeviceAddress = remote_login_info.ip
        hik_login_info.wPort = remote_login_info.port
        hik_login_info.sUserName = remote_login_info.user
        hik_login_info.sPassword = remote_login_info.pwd
        login_id = DllHandle.NET_DVR_Login_V40(pointer(hik_login_info), pointer(hik_device_info))
        DllHandle.NET_DVR_SetConnectTime(5000, 3)
        DllHandle.NET_DVR_SetReconnect(5000, 1)
        session_id = login_id
    else:
        session_id = Session._make(list(device_lists.get(device_id))).session_id
    if channel is None:
        channel = c_ulong(0xffffffff)
    tmp_time = hik_time()
    dev_info_list =  get_device_info_list()
    dev_info = None
    if device_id in dev_info_list:
        dev_info = dev_info_list.get(device_id)
    else:
        return ("", 0)
    #dev type
    try:
        dev_status_list_node = ET.Element("device_status_list")
        if dev_info and 0 < dev_info.struDeviceV30.byIPChanNum:#nvr or dvr.
            channel_map = {}
            invalid_channel = c_ulong(0xffffffff)
            channel_state = NET_DVR_DIGITAL_CHANNEL_STATE()
            channel_ret = c_ulong()
            memset(addressof(channel_state), 0, sizeof(NET_DVR_DIGITAL_CHANNEL_STATE))
            channel_tmp_ret = DllHandle.NET_DVR_GetDVRConfig(session_id, 6126, invalid_channel, pointer(channel_state),
                                                             sizeof(NET_DVR_DIGITAL_CHANNEL_STATE), pointer(channel_ret))
            bright_value = c_ushort()
            contrast_value = c_ushort()
            saturation_value = c_ushort()
            hue_value = c_ushort()
            dev_status_list_node.set("dev_count", str(dev_info.struDeviceV30.byIPChanNum))
            for item in range(dev_info.struDeviceV30.byIPChanNum):
                dest_channel = dev_info.struDeviceV30.byStartDChan+item
                tmp_ret = DllHandle.NET_DVR_GetVideoEffect(session_id, dest_channel, pointer(bright_value), pointer(contrast_value),
                                       pointer(saturation_value), pointer(hue_value))
                err_code = ""
                device_status_node = ET.SubElement(dev_status_list_node, "device_status")
                if tmp_ret:
                    device_status_node.text = 'true'
                else:
                    device_status_node.text = 'false'
                    err_code = DllHandle.NET_DVR_GetLastError()
                device_status_node.set('ip', str(remote_login_info.ip))
                device_status_node.set('port', str(remote_login_info.port))
                device_status_node.set('device_id', str(device_id))
                device_status_node.set('status_id', "{0}:{1}".format(str(device_id), str(dest_channel)))
                device_status_node.set('channel', str(dest_channel))
                device_status_node.set('error_node', str(err_code))
            status_xml = ET.tostring(dev_status_list_node, encoding='UTF-8', method='xml')
            return (status_xml, len(status_xml))
        else:#ipc
            ret = c_ulong()
            tmp_ret = DllHandle.NET_DVR_GetDVRConfig(session_id, 118, channel, pointer(tmp_time), sizeof(hik_time),
                                                     pointer(ret))
            out_str = "dll:{0} handle:{1} ret:{2}".format(str(DllHandle), str(session_id), str(tmp_ret))
            device_status_node = ET.SubElement(dev_status_list_node, 'device_status')
            err_code = ""
            dest_channel = 1
            if tmp_ret:
                device_status_node.text = 'true'
                dest_channel = dev_info.struDeviceV30.byStartChan
            else:
                device_status_node.text = 'false'
                err_code = DllHandle.NET_DVR_GetLastError()
            device_status_node.set('ip', str(remote_login_info.ip))
            device_status_node.set('port', str(remote_login_info.port))
            device_status_node.set('device_id', str(device_id))
            device_status_node.set('channel', str(dest_channel))
            device_status_node.set('status_id', "{0}:{1}".format(str(device_id), str(dest_channel)))
            device_status_node.set('error_node', str(err_code))
            status_xml = ET.tostring(dev_status_list_node, encoding='UTF-8', method='xml')
            #logger.info("get status id:{0} ip:{1} ret:{2} value:{3}, handle:{4}".format(str(device_id), str(remote_login_info.ip),
            #                                                                    str(tmp_ret), str(status_xml),
            #                                                                    str(session_id)))
            return (status_xml, len(status_xml))
    except:
        traceback.print_exc()
        logger.error('exception')
        return ('', 0)


@profile
def unregister_device(device_id):
    """ unregister a hikvision device"""
    global DllHandle
    cur_device_lists = get_device_lists()
    if device_id in cur_device_lists:
        if DllHandle.NET_DVR_Logout(cur_device_lists.get(device_id).session_id):
            logger.debug("deviceID:{0} logout success".format(device_id, cur_device_lists.get(device_id).session_id))
        else:
            logger.debug("deviceID:{0} logout failed".format(device_id, cur_device_lists(device_id).session_id))
        cur_device_lists.pop(device_id)

##------ PTZ Begin -------

def get_ptz_cmd_map():
    global ptz_cmd_map
    return ptz_cmd_map

def ptz(device_id, cmd, *args, **kwargs):
    dev_lists = get_device_lists()
    if device_id in device_lists:
        session_info = device_lists.get(device_id)
        handle = session_info.session_id
        cmd_map = get_ptz_cmd_map()
        if cmd in cmd_map:
            func = cmd_map.get(cmd)
            return func(handle, *args, **kwargs)
    return False
        #session_info.session_id
def move_left(handle, speed, b_stop, channel=None, **kwargs):
    global DllHandle
    dest_speed = int(7*speed)
    if handle is not None and 1 <= dest_speed and 7 >= dest_speed and channel is not None:
        ret = DllHandle.NET_DVR_PTZControlWithSpeed_Other(handle, channel, V_PTZ_CMD_TYPE.PAN_LEFT, b_stop, dest_speed)
        if not ret:
            err_code = c_long()
            err_code = DllHandle.NET_DVR_GetLastError()
            logger.warning("NET_DVR_PTZControlWithSpeed_Other failed, move left\
handle:{0} channel:{1} speed:{2} b_stop:{3} errNo:{4}".format(handle, channel, dest_speed, b_stop, err_code))
        else:
            logger.info("move left success handle:{0} channel:{1} speed:{2} b_stop:{3}".format(handle, channel, dest_speed, b_stop))
            return True
    return False

def move_right(handle, speed, b_stop, channel=None, **kwargs):
    global DllHandle
    dest_speed = int(7*speed)
    if handle is not None and 1 <= dest_speed and 7 >= dest_speed and channel is not None:
        ret = DllHandle.NET_DVR_PTZControlWithSpeed_Other(handle, channel, V_PTZ_CMD_TYPE.PAN_RIGHT, b_stop, dest_speed)
        if not ret:
            err_code = c_long()
            err_code = DllHandle.NET_DVR_GetLastError()
            logger.warning("NET_DVR_PTZControlWithSpeed_Other failed, move right\
handle:{0} channel:{1} speed:{2} b_stop:{3} errNo:{4}".format(handle, channel, dest_speed, b_stop, err_code))
        else:
            logger.info("move right success handle:{0} channel:{1} speed:{2} b_stop:{3}".format(handle, channel, dest_speed, b_stop))
            return True
    return False

def move_up(handle, speed, b_stop, channel=None, **kwargs):
    global DllHandle
    dest_speed = int(7*speed)
    if handle is not None and 1 <= dest_speed and 7 >= dest_speed and channel is not None:
        ret = DllHandle.NET_DVR_PTZControlWithSpeed_Other(handle, channel, V_PTZ_CMD_TYPE.TILT_UP, b_stop, dest_speed)
        if not ret:
            err_code = c_long()
            err_code = DllHandle.NET_DVR_GetLastError()
            logger.warning("NET_DVR_PTZControlWithSpeed_Other failed, move up\
handle:{0} channel:{1} speed:{2} b_stop:{3} errNo:{4}".format(handle, channel, dest_speed, b_stop, err_code))
        else:
            logger.info("move up success handle:{0} channel:{1} speed:{2} b_stop:{3}".format(handle, channel, dest_speed, b_stop))
            return True
    return False

def move_down(handle, speed, b_stop, channel=None, **kwargs):
    global DllHandle
    dest_speed = int(7*speed)
    if handle is not None and 1 <= dest_speed and 7 >= dest_speed and channel is not None:
        ret = DllHandle.NET_DVR_PTZControlWithSpeed_Other(handle, channel, V_PTZ_CMD_TYPE.TILT_DOWN, b_stop, dest_speed)
        if not ret:
            err_code = c_long()
            err_code = DllHandle.NET_DVR_GetLastError()
            logger.warning("NET_DVR_PTZControlWithSpeed_Other failed, move down\
handle:{0} channel:{1} speed:{2} b_stop:{3} errNo:{4}".format(handle, channel, dest_speed, b_stop, err_code))
        else:
            logger.info("move down success handle:{0} channel:{1} speed:{2} b_stop:{3}".format(handle, channel, dest_speed, b_stop))
            return True
    return False

def move_left_up(handle, speed, b_stop, channel=None, **kwargs):
    global DllHandle
    dest_speed = int(7*speed)
    if handle is not None and 1 <= dest_speed and 7 >= dest_speed and channel is not None:
        ret = DllHandle.NET_DVR_PTZControlWithSpeed_Other(handle, channel, V_PTZ_CMD_TYPE.LEFT_UP, b_stop, dest_speed)
        if not ret:
            err_code = c_long()
            err_code = DllHandle.NET_DVR_GetLastError()
            logger.warning("NET_DVR_PTZControlWithSpeed_Other failed, move left up\
handle:{0} channel:{1} speed:{2} b_stop:{3} errNo:{4}".format(handle, channel, dest_speed, b_stop, err_code))
        else:
            logger.info("move left up success handle:{0} channel:{1} speed:{2} b_stop:{3}".format(handle, channel, dest_speed, b_stop))
            return True
    return False

def move_left_down(handle, speed, b_stop, channel=None, **kwargs):
    global DllHandle
    dest_speed = int(7*speed)
    if handle is not None and 1 <= dest_speed and 7 >= dest_speed and channel is not None:
        ret = DllHandle.NET_DVR_PTZControlWithSpeed_Other(handle, channel, V_PTZ_CMD_TYPE.LEFT_DOWN, b_stop, dest_speed)
        if not ret:
            err_code = c_long()
            err_code = DllHandle.NET_DVR_GetLastError()
            logger.warning("NET_DVR_PTZControlWithSpeed_Other failed, move left down\
handle:{0} channel:{1} speed:{2} b_stop:{3} errNo:{4}".format(handle, channel, dest_speed, b_stop, err_code))
        else:
            logger.info("move left down success handle:{0} channel:{1} speed:{2} b_stop:{3}".format(handle, channel, dest_speed, b_stop))
            return True
    return False

def move_right_up(handle, speed, b_stop, channel=None, **kwargs):
    global DllHandle
    dest_speed = int(7*speed)
    if handle is not None and 1 <= dest_speed and 7 >= dest_speed and channel is not None:
        ret = DllHandle.NET_DVR_PTZControlWithSpeed_Other(handle, channel, V_PTZ_CMD_TYPE.RIGHT_UP, b_stop, dest_speed)
        if not ret:
            err_code = c_long()
            err_code = DllHandle.NET_DVR_GetLastError()
            logger.warning("NET_DVR_PTZControlWithSpeed_Other failed, move right up\
handle:{0} channel:{1} speed:{2} b_stop:{3} errNo:{4}".format(handle, channel, dest_speed, b_stop, err_code))
        else:
            logger.info("move right up success handle:{0} channel:{1} speed:{2} b_stop:{3}".format(handle, channel, dest_speed, b_stop))
            return True
    return False

def move_right_down(handle, speed, b_stop, channel=None, **kwargs):
    global DllHandle
    dest_speed = int(7*speed)
    if handle is not None and 1 <= dest_speed and 7 >= dest_speed and channel is not None:
        ret = DllHandle.NET_DVR_PTZControlWithSpeed_Other(handle, channel, V_PTZ_CMD_TYPE.RIGHT_DOWN, b_stop, dest_speed)
        if not ret:
            err_code = c_long()
            err_code = DllHandle.NET_DVR_GetLastError()
            logger.warning("NET_DVR_PTZControlWithSpeed_Other failed, move right down\
handle:{0} channel:{1} speed:{2} b_stop:{3} errNo:{4}".format(handle, channel, dest_speed, b_stop, err_code))
        else:
            logger.info("move right down success handle:{0} channel:{1} speed:{2} b_stop:{3}".format(handle, channel, dest_speed, b_stop))
            return True
    return False

def zoom_in(handle, speed, b_stop, channel=None, **kwargs):
    global DllHandle
    dest_speed = int(7*speed)
    if handle is not None and 1 <= dest_speed and 7 >= dest_speed and channel is not None:
        ret = DllHandle.NET_DVR_PTZControlWithSpeed_Other(handle, channel, V_PTZ_CMD_TYPE.ZOOM_IN, b_stop, dest_speed)
        if not ret:
            err_code = c_long()
            err_code = DllHandle.NET_DVR_GetLastError()
            logger.warning("NET_DVR_PTZControlWithSpeed_Other failed, zoom in \
handle:{0} channel:{1} speed:{2} b_stop:{3} errNo:{4}".format(handle, channel, dest_speed, b_stop, err_code))
        else:
            logger.info("zoom in success handle:{0} channel:{1} speed:{2} b_stop:{3}".format(handle, channel, dest_speed, b_stop))
            return True
    return False

def zoom_out(handle, speed, b_stop, channel=None, **kwargs):
    global DllHandle
    dest_speed = int(7*speed)
    if handle is not None and 1 <= dest_speed and 7 >= dest_speed and channel is not None:
        ret = DllHandle.NET_DVR_PTZControlWithSpeed_Other(handle, channel, V_PTZ_CMD_TYPE.ZOOM_OUT, b_stop, dest_speed)
        if not ret:
            err_code = c_long()
            err_code = DllHandle.NET_DVR_GetLastError()
            logger.warning("NET_DVR_PTZControlWithSpeed_Other failed, zoom out \
handle:{0} channel:{1} speed:{2} b_stop:{3} errNo:{4}".format(handle, channel, dest_speed, b_stop, err_code))
        else:
            logger.info("zoom out success handle:{0} channel:{1} speed:{2} b_stop:{3}".format(handle, channel, dest_speed, b_stop))
            return True
    return False

def focus_far(handle, speed, b_stop, channel=None, **kwargs):
    global DllHandle
    dest_speed = int(7*speed)
    if handle is not None and 1 <= dest_speed and 7 >= dest_speed and channel is not None:
        ret = DllHandle.NET_DVR_PTZControlWithSpeed_Other(handle, channel, V_PTZ_CMD_TYPE.FOCUS_FAR, b_stop, dest_speed)
        if not ret:
            err_code = c_long()
            err_code = DllHandle.NET_DVR_GetLastError()
            logger.warning("NET_DVR_PTZControlWithSpeed_Other failed, focus far \
handle:{0} channel:{1} speed:{2} b_stop:{3} errNo:{4}".format(handle, channel, dest_speed, b_stop, err_code))
        else:
            logger.info("focus far success handle:{0} channel:{1} speed:{2} b_stop:{3}".format(handle, channel, dest_speed, b_stop))
            return True
    return False

def focus_near(handle, speed, b_stop, channel=None, **kwargs):
    global DllHandle
    dest_speed = int(7*speed)
    if handle is not None and 1 <= dest_speed and 7 >= dest_speed and channel is not None:
        ret = DllHandle.NET_DVR_PTZControlWithSpeed_Other(handle, channel, V_PTZ_CMD_TYPE.FOCUS_NEAR, b_stop, dest_speed)
        if not ret:
            err_code = c_long()
            err_code = DllHandle.NET_DVR_GetLastError()
            logger.warning("NET_DVR_PTZControlWithSpeed_Other failed, focus near \
handle:{0} channel:{1} speed:{2} b_stop:{3} errNo:{4}".format(handle, channel, dest_speed, b_stop, err_code))
        else:
            logger.info("focus near success handle:{0} channel:{1} speed:{2} b_stop:{3}".format(handle, channel, dest_speed, b_stop))
            return True
    return False

def iris_open(handle, speed, b_stop, channel=None, **kwargs):
    global DllHandle
    dest_speed = int(7*speed)
    if handle is not None and 1 <= dest_speed and 7 >= dest_speed and channel is not None:
        ret = DllHandle.NET_DVR_PTZControlWithSpeed_Other(handle, channel, V_PTZ_CMD_TYPE.IRIS_OPEN, b_stop, dest_speed)
        if not ret:
            err_code = c_long()
            err_code = DllHandle.NET_DVR_GetLastError()
            logger.warning("NET_DVR_PTZControlWithSpeed_Other failed, iris open \
handle:{0} channel:{1} speed:{2} b_stop:{3} errNo:{4}".format(handle, channel, dest_speed, b_stop, err_code))
        else:
            logger.info("iris open success handle:{0} channel:{1} speed:{2} b_stop:{3}".format(handle, channel, dest_speed, b_stop))
            return True
    return False

def iris_close(handle, speed, b_stop, channel=None, **kwargs):
    global DllHandle
    dest_speed = int(7*speed)
    if handle is not None and 1 <= dest_speed and 7 >= dest_speed and channel is not None:
        ret = DllHandle.NET_DVR_PTZControlWithSpeed_Other(handle, channel, V_PTZ_CMD_TYPE.IRIS_CLOSE, b_stop, dest_speed)
        if not ret:
            err_code = c_long()
            err_code = DllHandle.NET_DVR_GetLastError()
            logger.warning("NET_DVR_PTZControlWithSpeed_Other failed, iris close \
handle:{0} channel:{1} speed:{2} b_stop:{3} errNo:{4}".format(handle, channel, dest_speed, b_stop, err_code))
        else:
            logger.info("iris close success handle:{0} channel:{1} speed:{2} b_stop:{3}".format(handle, channel, dest_speed, b_stop))
            return True
    return False

def heater(handle, speed, b_stop, channel=None, **kwargs):
    """
    """
    global DllHandle
    dest_speed = int(7*speed)
    if handle is not None and 1 <= dest_speed and 7 >= dest_speed and channel is not None:
        ret = DllHandle.NET_DVR_PTZControlWithSpeed_Other(handle, channel, V_PTZ_CMD_TYPE.HEATER_PWRON, b_stop, dest_speed)
        if not ret:
            err_code = c_long()
            err_code = DllHandle.NET_DVR_GetLastError()
            logger.warning("NET_DVR_PTZControlWithSpeed_Other failed, heater \
handle:{0} channel:{1} speed:{2} b_stop:{3} errNo:{4}".format(handle, channel, dest_speed, b_stop, err_code))
        else:
            logger.info("heater success handle:{0} channel:{1} speed:{2} b_stop:{3}".format(handle, channel, dest_speed, b_stop))
            return True
    return False

def light(handle, speed, b_stop, channel=None, **kwargs):
    global DllHandle
    dest_speed = int(7*speed)
    if handle is not None and 1 <= dest_speed and 7 >= dest_speed and channel is not None:
        ret = DllHandle.NET_DVR_PTZControlWithSpeed_Other(handle, channel, V_PTZ_CMD_TYPE.LIGHT_PWRON, b_stop, dest_speed)
        if not ret:
            err_code = c_long()
            err_code = DllHandle.NET_DVR_GetLastError()
            logger.warning("NET_DVR_PTZControlWithSpeed_Other failed, light \
handle:{0} channel:{1} speed:{2} b_stop:{3} errNo:{4}".format(handle, channel, dest_speed, b_stop, err_code))
        else:
            logger.info("light success handle:{0} channel:{1} speed:{2} b_stop:{3}".format(handle, channel, dest_speed, b_stop))
            return True
    return False

def wiper(handle, speed, b_stop, channel=None, **kwargs):
    global DllHandle
    dest_speed = int(7*speed)
    if handle is not None and 1 <= dest_speed and 7 >= dest_speed and channel is not None:
        ret = DllHandle.NET_DVR_PTZControlWithSpeed_Other(handle, channel, V_PTZ_CMD_TYPE.WIPER_PWRON, b_stop, dest_speed)
        if not ret:
            err_code = c_long()
            err_code = DllHandle.NET_DVR_GetLastError()
            logger.warning("NET_DVR_PTZControlWithSpeed_Other failed, wiper \
handle:{0} channel:{1} speed:{2} b_stop:{3} errNo:{4}".format(handle, channel, dest_speed, b_stop, err_code))
        else:
            logger.info("wiper success handle:{0} channel:{1} speed:{2} b_stop:{3}".format(handle, channel, dest_speed, b_stop))
            return True
    return False

def fan(handle, speed, b_stop, channel=None, **kwargs):
    global DllHandle
    dest_speed = int(7*speed)
    if handle is not None and 1 <= dest_speed and 7 >= dest_speed and channel is not None:
        ret = DllHandle.NET_DVR_PTZControlWithSpeed_Other(handle, channel, V_PTZ_CMD_TYPE.FAN_PWRON, b_stop, dest_speed)
        if not ret:
            err_code = c_long()
            err_code = DllHandle.NET_DVR_GetLastError()
            logger.warning("NET_DVR_PTZControlWithSpeed_Other failed, fan \
handle:{0} channel:{1} speed:{2} b_stop:{3} errNo:{4}".format(handle, channel, dest_speed, b_stop, err_code))
        else:
            logger.info("fan success handle:{0} channel:{1} speed:{2} b_stop:{3}".format(handle, channel, dest_speed, b_stop))
            return True
    return False

def preset_add(handle, index, channel=None, **kwargs):
    if handle is not None and channel is not None and 0 < index and 300 > index:
        ret = NET_DVR_PTZPreset_Other(handle, channel, V_PTZ_CMD_TYPE.SET_PRESET, index)
        if not ret:
            logger.warning("NET_DVR_PTZPreset_Other failed, errNo:{0}".format(DllHandle.NET_DVR_GetLastError()))
        else:
            return True
    return False

def preset_del(handle, index, channel=None, **kwargs):
    if handle is not None and channel is not None and 0 < index and 300 > index:
        ret = NET_DVR_PTZPreset_Other(handle, channel, V_PTZ_CMD_TYPE.DEL_PRESET, index)
        if not ret:
            logger.warning("NET_DVR_PTZPreset_Other failed, errNo:{0}".format(DllHandle.NET_DVR_GetLastError()))
        else:
            return True
    return False

def preset_goto():
    if handle is not None and channel is not None and 0 < index and 300 > index:
        ret = NET_DVR_PTZPreset_Other(handle, channel, V_PTZ_CMD_TYPE.GOTO_PRESET, index)
        if not ret:
            logger.warning("NET_DVR_PTZPreset_Other failed, errNo:{0}".format(DllHandle.NET_DVR_GetLastError()))
        else:
            return True
    return False

ptz_cmd_map = {V_PTZ_CMD_TYPE.PAN_LEFT: move_left, V_PTZ_CMD_TYPE.PAN_RIGHT:move_right, V_PTZ_CMD_TYPE.TILT_UP:move_up,
               V_PTZ_CMD_TYPE.TILT_DOWN:move_down, V_PTZ_CMD_TYPE.LEFT_UP:move_left_up,
               V_PTZ_CMD_TYPE.LEFT_DOWN: move_left_down, V_PTZ_CMD_TYPE.RIGHT_UP:move_right_up,
               V_PTZ_CMD_TYPE.RIGHT_DOWN:move_right_down, V_PTZ_CMD_TYPE.ZOOM_IN:zoom_in,
               V_PTZ_CMD_TYPE.ZOOM_OUT:zoom_out, V_PTZ_CMD_TYPE.FOCUS_FAR:focus_far,
               V_PTZ_CMD_TYPE.FOCUS_NEAR:focus_near, V_PTZ_CMD_TYPE.IRIS_OPEN:iris_open,
               V_PTZ_CMD_TYPE.IRIS_CLOSE:iris_close, V_PTZ_CMD_TYPE.HEATER_PWRON:heater,
               V_PTZ_CMD_TYPE.LIGHT_PWRON:light, V_PTZ_CMD_TYPE.WIPER_PWRON:wiper,
               V_PTZ_CMD_TYPE.FAN_PWRON:fan, V_PTZ_CMD_TYPE.SET_PRESET:preset_add,
               V_PTZ_CMD_TYPE.CLE_PRESET:preset_del, V_PTZ_CMD_TYPE.GOTO_PRESET:preset_goto}

##------ PTZ End   -------

@profile
def try_process_device(device):
    device_id = device.DeviceID
    ip = device.IP
    port = device.Port
    user = device.Username
    pwd = device.Password
    global DllHandle
    if sys.platform == 'win32':
        dll_path = os.path.abspath(os.path.join(os.path.dirname(__file__), 'HCNetSDK'))
        DllHandle = load_dll(dll_path)
        hik_login_info = login_info()
        hik_device_info = deviceinfo_v40()
        memset(addressof(hik_device_info), 0, sizeof(deviceinfo_v40))
        memset(addressof(hik_login_info), 0, sizeof(login_info))
        hik_login_info.s_DeviceAddress = ip
        hik_login_info.wPort = port
        hik_login_info.sUserName = user
        hik_login_info.sPassword = pwd
        login_id = DllHandle.NET_DVR_Login_V40(pointer(hik_login_info), pointer(hik_device_info))

        if login_id == -1:
            err_code = DllHandle.NET_DVR_GetLastError()
            logger.error("device_id:{0} ip{1} user:{2} pwd:{3} err:{4} try process failed.".format(\
                device_id, ip, user, pwd, err_code))
            return (device_id, False, 0, "hikvision")
        else:
            device.Manufacture = "hikvision"
            channel_list = list()
            if not device.ChannelList:
                device.ChannelList = channel_list
            if device:
                device.ProtocolFlag = 1
            if 0 < hik_device_info.struDeviceV30.byIPChanNum:
                ip_access_cfg = NET_DVR_IPPARACFG_V40()
                memset(addressof(ip_access_cfg), 0, sizeof(NET_DVR_IPPARACFG_V40))
                dw_ret = c_ulong()
                ret = DllHandle.NET_DVR_GetDVRConfig(login_id, 1062, 0, pointer(ip_access_cfg), sizeof(NET_DVR_IPPARACFG_V40), pointer(dw_ret))
                start_index = 0
                for item in range(hik_device_info.struDeviceV30.byIPChanNum):
                    #if ip_access_cfg.struStreamMode[item].uGetStream.struChanInfo.byEnable:
                        # print("ip:{0}channel:{1}user:{2}pwd:{3}port:{4}".format(ip_access_cfg.struIPDevInfo[item].struIP.sIpV4,
                        #                                                  ip_access_cfg.struStreamMode[item].uGetStream.struChanInfo.byChannel,
                        #                                                  str(ip_access_cfg.struIPDevInfo[item].sUserName.value),
                        #                                                  str(ip_access_cfg.struIPDevInfo[item].sPassword.value),
                        #                                                  ip_access_cfg.struIPDevInfo[item].wDVRPort))
                    ip = str(ip_access_cfg.struIPDevInfo[item].struIP.sIpV4)
                    channel = v_data.DmDeviceVideoChannel()
                    #channel.ChannelIndex = hik_device_info.struDeviceV30.byStartDChan + item
                    channel.ChannelIndex = start_index + item
                    channel.Name = "{0}-{1}".format(ip, channel.ChannelIndex)
                    if device.DeviceID:
                        channel.DeviceID = device.DeviceID
                    if device is not None:
                        channel_list.append(channel)
            else:
                channel_num = hik_device_info.struDeviceV30.byChanNum
                #channel_index = hik_device_info.struDeviceV30.byStartChan
                channel_index = 0
                while channel_num > 0:
                    channel = v_data.DmDeviceVideoChannel()
                    channel.ChannelIndex = channel_index
                    channel.Name = "{0}-{1}".format(ip, channel.ChannelIndex)
                    if device.DeviceID:
                        channel.DeviceID = device.DeviceID
                    if device:
                        channel_list.append(channel)
                    channel_num -= 1
                    channel_index += 1

            DllHandle.NET_DVR_Logout(login_id)
            logger.info("device_id:{0} ip{1} user:{2} pwd:{3} try process success, device:{4}."\
                        .format(device_id, ip, user, pwd, device))
            return (device_id, True, 1, "hikvision")
    else:
        logger.warning("linux process")
        return (device_id, False, 0, "hikvision")


##--------------------------------------------------------
def start_server():
    logger.debug('start_check status server.')
    device_status_manager = work_template.WorkerManager(16, 2)
    device_status_cache = dict()
    device_status_change_counts = dict()
    while True:
        device_lists = get_device_lists()
        logger.debug("register devices counts:{0}".format(len(device_lists)))
        device_status_lists = get_device_status_lists()
        for device_id, login_info in device_lists.items():
            device_status_manager.add_job(get_device_status, login_info.device_id)
        out_queue = get_status_queue()
        while not device_status_manager.result_queue_empty():
            out_str = device_status_manager.get_result()
            if 1 > len(out_str[0]):
                continue
            #device_status_node = ET.fromstring(out_str[0])
            device_status_list_node = ET.fromstring(out_str[0])
            #dev_node_id = device_status_node.get('device_id')
            #root_node = device_status_list_node.find("device_status_list")
            if device_status_list_node is not None:
                for device_status_node in device_status_list_node.iterfind("device_status"):
                    dev_status_id = device_status_node.get('status_id')
                    cur_status = str(device_status_node.text)
                    if dev_status_id in device_status_lists and str(device_status_node.text) != str(device_status_lists.get(dev_status_id)):
                        if dev_status_id in device_status_cache:
                            if device_status_cache[dev_status_id] > 2:
                                node_str = ET.tostring(device_status_node, encoding="UTF-8", method="xml")
                                out_queue.put(node_str)
                                device_status_lists[dev_status_id] = cur_status
                                device_status_cache[dev_status_id] = 0
                            else:
                                device_status_cache[dev_status_id] += 1
                        else:
                            device_status_cache[dev_status_id] = 1
                    elif dev_status_id in device_status_cache:
                        device_status_cache[dev_status_id] = 0
        time.sleep(5)


class StartServerThread(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self, name="get_all_status_thread")
        self.setDaemon(True)

    def run(self):
        start_server()


def test_dvr():
    try:
        device = v_data.DmDevice()
        device.DeviceID = "218.76.175.206"
        device.IP = "218.76.175.206"
        device.Port = 8000
        device.Username="admin"
        device.Password = "tysz12345"
        register_device(device.DeviceID, device.IP, device.Port, device.Username, device.Password)
        get_stream_url(device.DeviceID)
        device = v_data.DmDevice()
        device.DeviceID = "172.16.1.223"
        device.IP = "172.16.1.223"
        device.Port = 8000
        device.Username="admin"
        device.Password = "12345"
        register_device(device.DeviceID, device.IP, device.Port, device.Username, device.Password)
        get_stream_url(device.DeviceID)
        #try_process_device(device)
        #register_device('218.76.175.206', '218.76.175.206', 8000, 'admin', 'tysz12345')
        #get_stream_url('218.76.175.206')
        #get_device_status('218.76.175.206')
        raw_input()
    except:
        print(traceback.print_exc())

def test_ipc():
    try:
        device = v_data.DmDevice()
        device.DeviceID = "xxxx"
        device.IP = "172.16.1.192"
        device.Port = 8000
        device.Username="admin"
        device.Password = "vistek123456"
        register_device(device.DeviceID, device.IP, device.Port, device.Username, device.Password)
        get_stream_url(device.DeviceID)
        try_process_device(device)

        raw_input()
    except:
        print(traceback.print_exc())
##----------------------------------------------------------------------------------------
if __name__ == '__main__':
    try:
        #test_dvr()
        test_ipc()
        if sys.platform == 'win32':
            register_device('172.16.1.192', '172.16.1.192', 8000, 'admin', 'vistek123456')
            get_stream_url('172.16.1.192', 0)
            #register_device('218.76.175.206', '218.76.175.206', 8000, 'admin', 'tysz12345')
            #get_stream_url('218.76.175.206')
            ptz("172.16.1.192", V_PTZ_CMD_TYPE.PAN_LEFT, speed=1, channel=1, b_stop=0)
            time.sleep(10)
            ptz("172.16.1.192", V_PTZ_CMD_TYPE.PAN_LEFT, speed=1, channel=1, b_stop=1)
            raw_input()
    except:
        print(traceback.print_exc())
